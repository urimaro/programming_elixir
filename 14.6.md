14.5で実装した関数 `fib_calc/1` は非効率
中間結果をキャッシュしておけば効率が良い

モジュールは状態を持てない
プロセスは状態を持てる

Agent:
状態を持つプロセスをラップできるモジュール

ref. ch.19 タスクとエージェント

`Agent.start_link(fun, options)`
エージェントを生成し、 `fun` をサーバープロセスで実行し、初期状態のエージェントを以下の形式で返す
`{:ok, pid}`

`Agent.get_and_update(agent, fun, timeout)`
`fun` でエージェントの状態を取得、更新する
`fun` は、「現在のプロセスの状態を引数として渡して `fun` を実行するエージェント」に送られ、以下のtupleを返す
`{現在の値, 新しい状態のエージェント}`

`do_fib(cache, n)`
- `cache`: 計算済みのフィボナッチ数を格納したマップ
- `n`: 計算対象のインデックス

1. `cache[n]` が `nil` の場合  
    まだ計算されていないフィボナッチ数を求める

    1. 一つ前のフィボナッチ数を求める
    2. 以下の和を求める
        - 「1」で求めたフィボナッチ数
        - 「1」で求めたフィボナッチ数の一つ前のフィボナッチ数
    3. `cache` に以下の要素を追加する
        - key: n
        - value: 「2」の結果
    4. 以下のtupleを返す  
        `{「2」の結果, 「3」の結果}`
2. `cache[n]` が `nil` でない場合  
    以下のtupleを返す  
    `{cache[n], cache}`

```
goh@goh% elixir spawn/fib_agent.exs
4224696333392304878706725602341482782579852840250681098010280137314308584370130707224123599639141511088446087538909603607640194711643596029271983312598737326253555802606991585915229492453904998722256795316982874482472992263901833716778060607011615497886719879858311468870876264597369086722884023654422295243347964480139515349562972087652656069529806499841977448720155612802665404554171717881930324025204312082516817125
```

